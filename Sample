Promise의 javascript의 비동기 데이터처리시 "콜백중첩", "콜백지옥" 현상을 극복하기 위해 도입된 API 이다.
promise패턴을 사용하면 비동기 작업들을 순차적으로 진행하거나, 병렬로 진행하는 등의 컨트롤이 보다 수월해지고, 코드의 가독성이 좋아진다.
또한 내부적으로 예외처리에 대한 구조가 좋아서 우류 처리등에 대한 가시성이 좋다.

Promise 객체를 생성하면 resolve와 reject의 함수를 전달받게 되고, 작업이 성공하면 resolve()함수를 호출하여 resolve의 인자값을 then()으로 받게 되고
작업에 실패하면 reject()함수를 호출하여 reject의 인자값을 catch()로 받게 된다.

then()과 catch() 메서드는 또 다른 Promise 객체를 리턴합니다. 그리고 이 Promise 객체는 인자로 넘긴 콜백 함수의 리턴값을 다시 then()과 catch() 메서드를 통해 접근할 수 있도록 해줍니다.
다시 말하면 then()과 catch() 메서드는 마치 사슬처럼 계속 연결된 메소드 체이닝으로 동작이 되어진다.

예제 코드에서는 정상 image를 첨부 할 경우와 비정상 image를 첨부 할 경우에 대한 처리를 구분하여 비동기방식으로 이미지를 브라우저에서 보여주는 것을 처리 할 수있다.



특장점
1. Debounce
이벤트를 그룹화하여 특정시간이 지난 후 하나의 이벤트만 발생하도록 하는 기술입니다.

2. Throttle
이벤트를 일정한 주기마다 발생하도록 하는 기술입니다. 
실행 횟수에 제한을 거는 것이기 때문에 일반적으로 성능 문제 때문에 많이 사용합니다

예시
1.Debounce
- 사용자가 창 크기 조정을 멈출 때까지 기다렸다가 resizing event 사용하기 위해

2. Throttle
- 무한 스크롤링 페이지

자동완성 만들 경우, 일정 주기로 자동으로 완성되는 리스트를 보여주는 것에는
사용자 측면에서 Throttle (검색 되는 경험) 가 유리할 수 있지만, 성능상에서는 Debounce (1번만 호출) 가 훨씬 유리할 수 있다.

기법비교
이 두 가지 방법 모두 DOM 이벤트를 기반으로 실행하는 자바스크립트를 성능상의 이유로 JS의 양적인 측면, 즉 이벤트를 제어하는 방법입니다.
디바운싱과 스로틀의 가장 큰 차이점은 스로틀은 적어도 지정된 시간마다 정기적으로 기능 실행을 보장한다는 것입니다. Debounce 는 아무리 많은 이벤트가 발생해도 모두 무시하고 특정 시간사이에 어떤 이벤트도 발생하지 않았을 때 딱 한번만 마지막 이벤트를 발생시키는 기법입니다.


Hash 방식
Hash 방식은 URI 의 fragment identifier (예: #home )의 고유기능인 앵커(anchor) 를 사용한다.
fragment identifier는 URI 에서 # 으로 시작하는 문자열인데 hash 또는 hash mark 라고 불린다. <a href="#home">HOME</a>
href 어트리뷰트에 hash 를 사용한다. HOME 을 누르게 되면 hash 가 추가된 URI가 표시된다.
hash 가 추가되면 URL 이 동일한 상태에서 URI 만 바뀌므로 서버에 어떤 요청도 하지않는다.
다시말하면, hash 가 변경되어도 요청이 보내지지않으므로 페이지의 새로고침이 발생하지 않는다.

장점
기존의 AJAX 방식에서 히스토리 관리가 안됐다면 hash 방식은 히스토리 관리가 된다.

단점
여전히 SEO 이슈이다. 크롤러는 javascript 를 실행시키지 않기 때문에 hash 방식으로 만들어진 콘텐츠를 수집할 수 없다.

PJAX 방식
hash 방식의 가장 큰 단점인 SEO이슈인데 이를 보완한 방법이 PJAX(pushstate + ajax) 이다.
History API인 pushstate 와 popstate 를 사용한다.

<a href="/home">HOME</a>

AJAX 요청은 주소창의 URL을 변경시키지않아 히스토리 관리가 안되는데
이 때 pushstate를 사용하면 주소창의 URL은 변경되고 히스토리가 남지만 요청을 하지 않으므로 페이지가 갱신되진 않아 브라우저의 뒤로가기에 대응이 가능하다..

PJAX 는 페이지마다 고유의 URL 이 존재하기 때문에 SEO를 보완하는 장점이 있지만, 구현방식이 어려운 단점이 있다.
